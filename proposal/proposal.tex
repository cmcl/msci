\documentclass{mprop}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[style=alphabetic,natbib=true,maxbibnames=100]{biblatex}
\addbibresource{proposal.bib}

% alternative font if you prefer
%\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Formalisation of Session-based Lambda Calculus Type Systems}
\author{Craig McLaughlin}
\date{\today}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

Two aspects of programming language research are relevant for this project. The first is concerned with static type systems for ensuring runtime safety properties for concurrent communication systems. The second is the increasing use of proof assistants and interactive theorem provers, for studying and mechanically verifying the semantics and properties of programming languages.

\subsection{On Communication}

Distributed communication systems are becoming increasingly prevalent in modern society. To facilitate communication between concurrently executing agents requires complex network protocols to define the type and sequencing of messages. Typically these protocols are implemented in systems programming languages, such as C, which provide no correctness guarantees of the implementation. Furthermore, programming in these languages is often extremely error-prone, as one has a myriad of unsafe features at one's disposal. As more businesses begin to conduct transactions over the Web, it is imperative that they can reason about the communication protocols upon which they rely.

Encoding communication protocols as \textit{session types} is one approach to achieve guarantees about correctness. One particular variant of session types are \textit{binary} session types~\footnote{There are also \textit{multiparty} session types, but I do not discuss them here.}. A binary session type specifies communication between two agents, and it specifies the order and type of messages to be sent or received by an agent in the system. The two agents have dual session types such that, for example, when one is expecting to receive a message the other is expecting to send a message; both session types agree on the type of message to be exchanged. In this way, correctness of communication can be statically assured by providing communicating agents with \textit{channels} that have dual session types. A channel is defined as a bi-directional conduit for exchanging messages, not unlike a socket in network programming. In contrast to sockets, however, a channel is associated with an explicit type which provides a description of its protocol. Thus, in session-based systems a channel is usually provided as a primitive type.

\subsection{On Verification}

In programming language research, work on static type systems is usually presented on paper complete with informal proofs of correctness for the system properties. Most types systems in the session types community have been developed in this way. However, it is more difficult to extend work using this approach as may be unclear how changes affect proofs and one will typically have to re-consider all proofs to be convinced the properties still hold. More generally, unassisted formalisms are error-prone to develop and do not provide a firm basis upon which other researchers can experiment; often it will require ``rolling your own'' compiler for the language of interest.

Proof assistants such as Coq~\cite{Coq:manual} offer a platform on which to develop programming languages and type systems and associated proofs of properties with strong guarantees of correctness. Not only is proving with a proof assistant much less error-prone than the unaided approach, it also eases extension of the system since the proof assistant will highlight parts of proofs that have been affected by changes. However, one may have to prove more properties using this approach since this setting does not permit appealing to human intuition. For example, alpha-equivalence and freshness and binders are usually assumed in informal presentations, whereas in the mechanised setting one has to explicitly encode and reason about these properties~\cite{Aydemir:2005:MMM, Aydemir:2008:EFM}.

Interactive theorem proving and proof assistants has seen an upsurge in use in recent years. Especially within the domain of programming language research, there is a strong emphasis on providing mechanised proofs accompanying work in the area. Indeed, \citeauthor{Aydemir:2005:MMM} have published a series of challenges on mechanising programming languages aimed at providing a starting point for comparing different representation techniques~\cite{Aydemir:2005:MMM}. Another aim is to provide reusable libraries for common reasoning needed across programming language developments, e.g. handling of typing environments. This effort has resulted in a number of different approaches for representing programming languages within proof assistants. For instance, \citeauthor{Aydemir:2008:EFM}~\cite{Aydemir:2008:EFM} present a representation of lambda calculi where bound variables are represented as \textit{de Bruijn indices}~\footnote{A de Bruijn index is a number used to represent a bound variable which indicates the position of its binder (starting from zero for the innermost binder). For example, $\lambda~(\lambda~1)$ corresponds to $\lambda x. \lambda y. x$, i.e. the constant function.} and free variables are represented as named terms; the \textit{locally nameless} representation. Their work resulted in a library for handling commonly occurring aspects in programming lanuage metatheory which has been used since in other developments~\cite{Park:2014:MMW}. Resuable libaries reduce the proof engineering effort needed for later works, in contrast to the pen-and-paper approach, and some proof assistants (as is the case with Coq) allow one to extract a program from the development which can provide a typechecker or compiler for the language formalised~\footnote{Curry-Howard strikes again; a proof of decidability of typechecking corresponds to a program implementing a typechecker for the language.}

%% Most research on session type systems has consisted of an informal presentation of the languages being defined. That is, the semantics and proofs are performed manually rather than aided by a proof assistant.

%% POPLMARK
%% save on proof engineering effort as is championed by the POPLMARK challenge aimed at reducing the effort for researchers to code programming language metatheory it provides a library needed to perform various things define various parts of programming languages viewed to be difficult to formalise including handling binders and freshness they also mention handling of linear typing but renege on actually formulating this as part of their challenge they insist it is a future work here is the future
%% Metatheory library

%% correctness and something what else could we say i think it would appropriate
%% to mention that the session types studied so far include both pi and lambda
%% calculi and it may be beneficil if the reader was informed also the pi
%% calculus paradigms do not fit well into the existing mainstream programming
%% language paradigms this seems like it should be in the statement of the problem section down below also i should read more of jtod's slides because this writing just keep writing malarky might just be what i need to pound out the pages because it eliminates thoughts as they come into the head what else adopt and focus we have in the problem statement but perhaps those paragraphs should be re-jigged for up here multithreaded functional programming with linear typing for session types a number of these systems use different type systems but they are based on all the lambda calculus fundamentally so to have a generic framework to encode these variants would 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statement of Problem}

The aim of this project is to develop a framework for formalising lambda
calculus type systems involving session types using interactive theorem
proving (in particular, the system Coq). The motivation for the framework is
that it will enable a whole class of related languages and type systems to be
formalised with little extra proof effort. Inspired by previous work on a
mechanised framework for pi calculus type systems~\cite{Gay:2001:FFP} we
shift to the lambda calculus to provide a basis on which session types for
mainstream programming languages can be studied whilst taking advantage of
previous proof effort and specialising only for those parts unique to the
particular system. The framework will be heavily based on calculi developed by \citeauthor{Walder:2012}~\cite{Wadler:2012} describing a relationship between classical linear logic (based on previous work by \citeauthor{Caires:2010:STI}~\cite{Caires:2010:STI}) and a functional session-based language (based on previous work by \citeauthor{Gay:2010:LAST}~\cite{Gay:2010:LAST}).

These ideas can be expanded by considering the recent work by \citeauthor{Lindley:2014:SAP} \cite{Lindley:2014:SAP} who extend GV by \cite{Wadler:2012} to HGV, supporting session forwarding, replication and polymorphism.

From the generic framework, a number of directions can be explored including
session polymorphism, session subtyping, and permitting different forms of
aliasing within the type system. Initially, it will be interesting to extend the work of \citeauthor{Walder:2012} to consider session polymorphism corresponding to the quantifiers in the CP process calculus

The majority of previous session type systems for mainstream programming languages have focussed exclusively on linear type systems. One disadvantage of a linear type system is the need to re-bind objects after each operation~\cite{Gay:2010:LAST}. Principally, we intend to instantiate the framework with a type system that provides the benefits of aliasing with the guarantees of linearity, termed ``adoption and focus''. The ``adoption and focus'' type system is non-trivial requiring special language features, e.g. to manage capabilities which can be thought as a form of object liveness mechanism, so the framework design must support such flexibility by, e.g allowing the typing judgements to be extended such that the capabilities can be included in soundness results. The instantiation will demonstrate that the framework supports a wide range of languages and type systems providing researchers the ability to harness the power of formal verification in the design, implementation and documentation of session-based type systems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background Survey}

present an overview of relevant previous work including articles, books, and
existing software products. Critically evaluate the strengths and weaknesses
of the previous work.

Here I will briefly distinguish between pi and lambda calculi, since the majority of mechanisations have been in the pi calculus. I will then discuss the various systems which have been informally formalised. A possible outline of a plan:

System F-pop~\cite{Mazurak:2010:LLT}
session polymorphism formalised in Coq, Simon's Isabelle/HOL
development.
Philip Wadler's Propositions as Sessions~\cite{Wadler:2012}
Simon J. Gay and Vasco Vasconcelos (LAST)~\cite{Gay:2010:LAST}
Lolliproc~\cite{Mazurak:2010:LCC}
\citeauthor{Mazurak:2013:LPP}'s PhD thesis~\cite{Mazurak:2013:LPP}

Roughly can be split into

type systems (pi and lambda)

session type mechanisations

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}

state how you propose to solve the software development problem. Show that
your proposed approach is feasible, but identify any risks.

First order approach taken - represent bound variables as de Bruijn indices
In contrast to a higher-order approach
though the first-order encoding has its disadvantages namely one has to reason about variable substitution since without a higher-order approach this is not handled automatically by the meta-language
the locally nameless representation is chosen with a few simplifying assumptions regarding variable substitution and closed terms

Engineering Formal Metatheory
Abstract:

Formalising programming languages within a proof assistant is becoming a
more widely adopted convention within the research community in lieu of hand
written proofs.

Review:

Discussing issues in engineering metatheory for programming languages.
Focus was on the locally nameless representation for binders with names
for free variables and de Brujin indices for bound variables. There was
also novel use of cofinite quantification to rules with bindings to increase
the strength of the induction principles and reduce the amount of renaming
of bound variables (due to freshness issues) significantly. The theory was
tested with formalisations of the simply-typed lambda calculus,
System $F_{<:}$,
the calculus of constructions. The formalisations followed the POPLMARK
challenge (type soundness, preservation, progress).


HOAS Coq formalisation using Metatheory library from UPenn.
Explain why this approach was taken versus intrinsic encoding of the terms

The intrinsic encoding as described by~\citeauthor{Benton:2012:STT}~\cite{Benton:2012:STT} is one approach for encoding programming languages based on the lambda calculus. The key idea here is that terms are indexed by their type so as to prevent ill-formed terms from being constructed. However, in the encoding for GV there are issues with using this encoding: $(1)$ it is not immediately clear how to handle linear contexts using the de Bruijn variable encoding, since in the instrinic setting the environment supports weakening; $(2)$ an instrinic encoding of terms would be complicated by the need to enforce session types occur in certain instances (by use of a predicate); and $(3)$ well-typed terms require extra assumptions about binder freshness which cannot reasonably be expressed as a function type. For these reasons, an instrinic approach does not offer much benefit since a well-typed term relation would still need to be defined. I chose the ..... encoding


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

show how you plan to organize your work, identifying intermediate deliverables
and dates.

I need to perform some formalisation of the system. I should identify the key
issues (linear typing, bindings (as claimed in the literature), etc).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printbibliography

\end{document}
