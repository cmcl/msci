\documentclass{mprop}

\usepackage{graphicx}
\usepackage[style=alphabetic,natbib=true]{biblatex}
\addbibresource{proposal.bib}

% alternative font if you prefer
%\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Formalisation of Session-based Lambda Calculus Type Systems}
\author{Craig McLaughlin}
\date{\today}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

Two aspects of programming language research are relevant for the problem. The first is concerned with static type systems for ensuring runtime safety properties for concurrent communication systems. The second is the increasing use of proof assistants and interactive theorem provers, for studying and mechanically verifying the semantics and properties of programming languages.

\subsection{On Communication}

Distributed communication systems are becoming increasing prevalent in modern society. To facilitate communication between concurrently executing agents requires complex network protocols to define the type and sequencing of messages. Typically these protocols are implemented in systems programming languages, such as C, which provide no correctness guarantees of the implementation. Furthermore, programming in these languages is often extremely error-prone, as one has a myriad of unsafe features at one's disposal. As more businesses begin to conduct transactions over the Web, it is imperative that they can reason about the communication protocols upon which they rely.

Encoding communication protocols as \textit{session types} is one approach to achieve guarantees about correctness. One particular variant of session types are \textit{binary} session types~\footnote{There are also \textit{multiparty} session types, but I do not discuss them here.}. A binary session type specifies communication between two agents, and it specifies the order and type of messages to be sent or received by an agent in the system. The two agents have dual session types such that, for example, when one is expecting to receive a message the other is expecting to send a message; both session types agree on the type of message to be exchanged. In this way, correctness of communication can be statically assured by providing communicating agents with \textit{channels} that have dual session types. A channel is defined as a bi-directional conduit for exchanging messages, not unlike a socket in network programming. In contrast to sockets, however, a channel is associated with an explicit type which provides a description of its protocol. Thus, in session-based systems a channel is usually provided as a primitive type.

\subsection{On Verification}

construct an argument for the use of a proof assistant and interactive theorem proving technologies to formalise a framework for developing type systems involving session types that are based on lambda calculi so that we can use such a development to reason about a variety of type systems while minimising proof effort tie this into an introduction into the subfield of session types and what they are good for essentially motivating our project in this space additionally we can introduce the reader to the discipline of interactivetheorem proving and formal methods more generally as a way to formalise programming languages highlighting the benefits of reusability increased

correctness and something what else could we say i think it would appropriate
to mention that the session types studied so far include both pi and lambda
calculi and it may be beneficil if the reader was informed also the pi
calculus paradigms do not fit well into the existing mainstream programming
language paradigms this seems like it should be in the statement of the problem section down below also i should read more of jtod's slides because this writing just keep writing malarky might just be what i need to pound out the pages because it eliminates thoughts as they come into the head what else adopt and focus we have in the problem statement but perhaps those paragraphs should be re-jigged for up here multithreaded functional programming with linear typing for session types a number of these systems use different type systems but they are based on all the lambda calculus fundamentally so to have a generic framework to encode these variants would save on proof engineering effort as is championed by the POPLMARK challenge aimed at reducing the effort for researchers to code programming language metatheory it provides a library needed to perform various things define various parts of programming languages viewed to be difficult to formalise including handling binders and freshness they also mention handling of linear typing but renege on actually formulating this as part of their challenge they insist it is a future work here is the future


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statement of Problem}

clearly state the problem to be addressed in your forthcoming project. Explain
why it would be worthwhile to solve this problem.

The aim of this project is to develop a framework for formalising lambda
calculus type systems involving session types using interactive theorem
proving (in particular, the system Coq). The motivation for the framework is
that it will enable a whole class of related languages and type systems to be
formalised with little extra proof effort. Inspired by previous work on a
mechanised framework for pi calculus type systems~\cite{Gay:2001:FFP}, we
shift to the lambda calculus to provide a basis on which session types for
mainstream programming languages can be studied whilst taking advantage of
previous proof effort and specialising only for those parts unique to the
particular system.

From the generic framework, a number of directions can be explored including
session polymorphism, session subtyping, and permitting different forms of
aliasing within the type system. The majority of previous session type systems
for mainstream programming languages has focussed exclusively on linear type
systems. One disadvantage of a linear type system is the need to re-bind
objects after each operation~\cite{Gay:2010:LAST}. Principally, we intend to
instantiate the framework with a type system that provides the benefits of
aliasing with the guarantees of linearity, termed ``adoption and focus''. The
``adoption and focus'' type system is non-trivial requiring special language
features, e.g. to manage capabilities which can be thought as a form of object
liveness mechanism, so the framework design must support such flexibility by,
e.g allowing the typing judgements to be extended such that the capabilities
can be included in soundness results. The instantiation will demonstrate that
the framework supports a wide range of languages and type systems providing
researchers the ability to harness the power of formal verification in the
design, implementation and documentation of session-based type systems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background Survey}

present an overview of relevant previous work including articles, books, and
existing software products. Critically evaluate the strengths and weaknesses
of the previous work.

System F-pop~\cite{Mazurak:2010:LLT}
session polymorphism formalised in Coq, Simon's Isabelle/HOL
development.
Philip Wadler's Propositions as Sessions~\cite{Wadler:2012}
Simon J. Gay and Vasco Vasconcelos (LAST)~\cite{Gay:2010:LAST}
Lolliproc~\cite{Mazurak:2010:LCC}
PhD thesis~\cite{Mazurak:2013:LPP}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}

state how you propose to solve the software development problem. Show that
your proposed approach is feasible, but identify any risks.

HOAS Coq formalisation using Metatheory library from UPenn.
Explain why this approach was taken versus intrinsic encoding of the terms

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

show how you plan to organize your work, identifying intermediate deliverables
and dates.

I need to perform some formalisation of the system. I should identify the key
issues (linear typing, bindings (as claimed in the literature), etc).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printbibliography

\end{document}
