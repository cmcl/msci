\documentclass{mprop}

\usepackage{graphicx}
\usepackage[style=alphabetic,natbib=true]{biblatex}
\addbibresource{proposal.bib}

% alternative font if you prefer
%\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Formalisation of Session-based Lambda Calculus Type Systems}
\author{Craig McLaughlin}
\date{\today}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

Two aspects of programming language research are relevant for this project. The first is concerned with static type systems for ensuring runtime safety properties for concurrent communication systems. The second is the increasing use of proof assistants and interactive theorem provers, for studying and mechanically verifying the semantics and properties of programming languages.

\subsection{On Communication}

Distributed communication systems are becoming increasingly prevalent in modern society. To facilitate communication between concurrently executing agents requires complex network protocols to define the type and sequencing of messages. Typically these protocols are implemented in systems programming languages, such as C, which provide no correctness guarantees of the implementation. Furthermore, programming in these languages is often extremely error-prone, as one has a myriad of unsafe features at one's disposal. As more businesses begin to conduct transactions over the Web, it is imperative that they can reason about the communication protocols upon which they rely.

Encoding communication protocols as \textit{session types} is one approach to achieve guarantees about correctness. One particular variant of session types are \textit{binary} session types~\footnote{There are also \textit{multiparty} session types, but I do not discuss them here.}. A binary session type specifies communication between two agents, and it specifies the order and type of messages to be sent or received by an agent in the system. The two agents have dual session types such that, for example, when one is expecting to receive a message the other is expecting to send a message; both session types agree on the type of message to be exchanged. In this way, correctness of communication can be statically assured by providing communicating agents with \textit{channels} that have dual session types. A channel is defined as a bi-directional conduit for exchanging messages, not unlike a socket in network programming. In contrast to sockets, however, a channel is associated with an explicit type which provides a description of its protocol. Thus, in session-based systems a channel is usually provided as a primitive type.

\subsection{On Verification}

Interactive theorem proving and proof assistants has seen an upsurge in recent years. Especially within the domain of programming language research, there is a strong emphasis now on providing mechanised proofs accompanying any work in the area. 

POPLMARK
--------
SPL (+CPL)
* Most formalisations are informal, making it difficult to extend the development to a larger setting.
* Mistakes can easily slip into a development nullifying work
* Considerable manual effort must be expended to update all proofs to support an extension and it is not immediately obvious which definitions may need updated
* A lot of proof assistants offer a platform with which to study languages rigorously
WTD


The increasing use of proof assitants and interactive theorem proving in programming language research has spiked....

Most research on session type systems has consisted of an informal presentation of the languages being defined. That is, the semantics and proofs are performed manually rather than aided by a proof assistant.

POPLMARK
save on proof engineering effort as is championed by the POPLMARK challenge aimed at reducing the effort for researchers to code programming language metatheory it provides a library needed to perform various things define various parts of programming languages viewed to be difficult to formalise including handling binders and freshness they also mention handling of linear typing but renege on actually formulating this as part of their challenge they insist it is a future work here is the future
Metatheory library

construct an argument for the use of a proof assistant and interactive theorem proving technologies to formalise a framework for developing type systems involving session types that are based on lambda calculi so that we can use such a development to reason about a variety of type systems while minimising proof effort tie this into an introduction into the subfield of session types and what they are good for essentially motivating our project in this space additionally we can introduce the reader to the discipline of interactivetheorem proving and formal methods more generally as a way to formalise programming languages highlighting the benefits of reusability increased

correctness and something what else could we say i think it would appropriate
to mention that the session types studied so far include both pi and lambda
calculi and it may be beneficil if the reader was informed also the pi
calculus paradigms do not fit well into the existing mainstream programming
language paradigms this seems like it should be in the statement of the problem section down below also i should read more of jtod's slides because this writing just keep writing malarky might just be what i need to pound out the pages because it eliminates thoughts as they come into the head what else adopt and focus we have in the problem statement but perhaps those paragraphs should be re-jigged for up here multithreaded functional programming with linear typing for session types a number of these systems use different type systems but they are based on all the lambda calculus fundamentally so to have a generic framework to encode these variants would 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statement of Problem}

clearly state the problem to be addressed in your forthcoming project. Explain
why it would be worthwhile to solve this problem.

The aim of this project is to develop a framework for formalising lambda
calculus type systems involving session types using interactive theorem
proving (in particular, the system Coq). The motivation for the framework is
that it will enable a whole class of related languages and type systems to be
formalised with little extra proof effort. Inspired by previous work on a
mechanised framework for pi calculus type systems~\cite{Gay:2001:FFP}, we
shift to the lambda calculus to provide a basis on which session types for
mainstream programming languages can be studied whilst taking advantage of
previous proof effort and specialising only for those parts unique to the
particular system.

From the generic framework, a number of directions can be explored including
session polymorphism, session subtyping, and permitting different forms of
aliasing within the type system. The majority of previous session type systems
for mainstream programming languages has focussed exclusively on linear type
systems. One disadvantage of a linear type system is the need to re-bind
objects after each operation~\cite{Gay:2010:LAST}. Principally, we intend to
instantiate the framework with a type system that provides the benefits of
aliasing with the guarantees of linearity, termed ``adoption and focus''. The
``adoption and focus'' type system is non-trivial requiring special language
features, e.g. to manage capabilities which can be thought as a form of object
liveness mechanism, so the framework design must support such flexibility by,
e.g allowing the typing judgements to be extended such that the capabilities
can be included in soundness results. The instantiation will demonstrate that
the framework supports a wide range of languages and type systems providing
researchers the ability to harness the power of formal verification in the
design, implementation and documentation of session-based type systems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background Survey}

present an overview of relevant previous work including articles, books, and
existing software products. Critically evaluate the strengths and weaknesses
of the previous work.

Here I will briefly distinguish between pi and lambda calculi, since the majority of mechanisations have been in the pi calculus. I will then discuss the various systems which have been informally formalised. A possible outline of a plan:

System F-pop~\cite{Mazurak:2010:LLT}
session polymorphism formalised in Coq, Simon's Isabelle/HOL
development.
Philip Wadler's Propositions as Sessions~\cite{Wadler:2012}
Simon J. Gay and Vasco Vasconcelos (LAST)~\cite{Gay:2010:LAST}
Lolliproc~\cite{Mazurak:2010:LCC}
\citeauthor{Mazurak:2013:LPP}'s PhD thesis~\cite{Mazurak:2013:LPP}

Roughly can be split into

type systems (pi and lambda)

session type mechanisations

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}

state how you propose to solve the software development problem. Show that
your proposed approach is feasible, but identify any risks.

First order approach taken - represent bound variables as de Bruijn indices
In contrast to a higher-order approach
though the first-order encoding has its disadvantages namely one has to reason about variable substitution since without a higher-order approach this is not handled automatically by the meta-language
the locally nameless representation is chosen with a few simplifying assumptions regarding variable substitution and closed terms

Engineering Formal Metatheory
Abstract:

Formalising programming languages within a proof assistant is becoming a
more widely adopted convention within the research community in lieu of hand
written proofs.

Review:

Discussing issues in engineering metatheory for programming languages.
Focus was on the locally nameless representation for binders with names
for free variables and de Brujin indices for bound variables. There was
also novel use of cofinite quantification to rules with bindings to increase
the strength of the induction principles and reduce the amount of renaming
of bound variables (due to freshness issues) significantly. The theory was
tested with formalisations of the simply-typed lambda calculus, System F_sub,
the calculus of constructions. The formalisations followed the POPLMARK
challenge (type soundness, preservation, progress).


HOAS Coq formalisation using Metatheory library from UPenn.
Explain why this approach was taken versus intrinsic encoding of the terms

The intrinsic encoding as described by~\citeauthor{Benton:2012:STT}~\cite{Benton:2012:STT} is one approach for encoding programming languages based on the lambda calculus. The key idea here is that terms are indexed by their type so as to prevent ill-formed terms from being constructed. However, in the encoding for GV there are issues with using this encoding: $(1)$ it is not immediately clear how to handle linear contexts using the de Bruijn variable encoding, since in the instrinic setting the environment supports weakening; $(2)$ an instrinic encoding of terms would be complicated by the need to enforce session types occur in certain instances (by use of a predicate); and $(3)$ well-typed terms require extra assumptions about binder freshness which cannot reasonably be expressed as a function type. For these reasons, an instrinic approach does not offer much benefit since a well-typed term relation would still need to be defined. I chose the ..... encoding


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

show how you plan to organize your work, identifying intermediate deliverables
and dates.

I need to perform some formalisation of the system. I should identify the key
issues (linear typing, bindings (as claimed in the literature), etc).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printbibliography

\end{document}
