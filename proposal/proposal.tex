\documentclass{mprop}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[style=alphabetic,natbib=true,maxbibnames=100]{biblatex}
\addbibresource{proposal.bib}

% alternative font if you prefer
%\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Formalisation of Session-based Lambda Calculus Type Systems}
\author{Craig McLaughlin}
\date{\today}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

Two aspects of programming language research are relevant for this project. The first is concerned with static type systems for ensuring runtime safety properties for concurrent communication systems. The second is the increasing use of proof assistants and interactive theorem provers, for studying and mechanically verifying the semantics and properties of programming languages.

\subsection{On Communication}

Distributed communication systems are becoming increasingly prevalent in modern society. To facilitate communication between concurrently executing agents requires complex network protocols to define the type and sequencing of messages. Typically these protocols are implemented in systems programming languages, such as C, which provide no correctness guarantees of the implementation. Furthermore, programming in these languages is often extremely error-prone, as one has a myriad of unsafe features at one's disposal. As more businesses begin to conduct transactions over the Web, it is imperative that they can reason about the communication protocols upon which they rely.

Encoding communication protocols as \textit{session types} is one approach to achieve guarantees about correctness. One particular variant of session types are \textit{binary} session types~\footnote{There are also \textit{multiparty} session types, but I do not discuss them here.}. A binary session type specifies communication between two agents, and it specifies the order and type of messages to be sent or received by an agent in the system. The two agents have dual session types such that, for example, when one is expecting to receive a message the other is expecting to send a message; both session types agree on the type of message to be exchanged. In this way, correctness of communication can be statically assured by providing communicating agents with \textit{channels} that have dual session types. A channel is defined as a bi-directional conduit for exchanging messages, not unlike a socket in network programming. In contrast to sockets, however, a channel is associated with an explicit type which provides a description of its protocol. Thus, in session-based systems a channel is usually provided as a primitive type.

\subsection{On Verification}

In programming language research, work on static type systems is usually presented on paper complete with informal proofs of correctness for the system properties. Most types systems in the session types community have been developed in this way. However, it is more difficult to extend work using this approach as may be unclear how changes affect proofs and one will typically have to re-consider all proofs to be convinced the properties still hold. More generally, unassisted formalisms are error-prone to develop and do not provide a firm basis upon which other researchers can experiment; often it will require ``rolling your own'' compiler for the language of interest.

Proof assistants such as Coq~\cite{Coq:manual} offer a platform on which to develop programming languages and type systems and associated proofs of properties with strong guarantees of correctness. Not only is proving with a proof assistant much less error-prone than the unaided approach, it also eases extension of the system since the proof assistant will highlight parts of proofs that have been affected by changes. However, one may have to prove more properties using this approach since this setting does not permit appealing to human intuition. For example, alpha-equivalence and freshness and binders are usually assumed in informal presentations, whereas in the mechanised setting one has to explicitly encode and reason about these properties~\cite{Aydemir:2005:MMM, Aydemir:2008:EFM}.

Interactive theorem proving and proof assistants has seen an upsurge in use in recent years. Especially within the domain of programming language research, there is a strong emphasis on providing mechanised proofs accompanying work in the area. Indeed, \citeauthor{Aydemir:2005:MMM} have published a series of challenges on mechanising programming languages aimed at providing a starting point for comparing different representation techniques~\cite{Aydemir:2005:MMM}. Another aim is to provide reusable libraries for common reasoning needed across programming language developments, e.g. handling of typing environments. This effort has resulted in a number of different approaches for representing programming languages within proof assistants. For instance, \citeauthor{Aydemir:2008:EFM}~\cite{Aydemir:2008:EFM} present a representation of lambda calculi where bound variables are represented as \textit{de Bruijn indices}~\footnote{A de Bruijn index is a number used to represent a bound variable which indicates the position of its binder (starting from zero for the innermost binder). For example, $\lambda~(\lambda~1)$ corresponds to $\lambda x. \lambda y. x$, i.e. the constant function.} and free variables are represented as named terms; the \textit{locally nameless} representation. Their work resulted in a library for handling commonly occurring aspects in programming lanuage metatheory which has been used since in other developments~\cite{Park:2014:MMW}. Resuable libaries reduce the proof engineering effort needed for later works, in contrast to the pen-and-paper approach, and some proof assistants (as is the case with Coq) allow one to extract a program from the development which can provide a typechecker or compiler for the language formalised~\footnote{Curry-Howard strikes again; a proof of decidability of typechecking corresponds to a program implementing a typechecker for the language.}

%% Most research on session type systems has consisted of an informal presentation of the languages being defined. That is, the semantics and proofs are performed manually rather than aided by a proof assistant.

%% POPLMARK
%% save on proof engineering effort as is championed by the POPLMARK challenge aimed at reducing the effort for researchers to code programming language metatheory it provides a library needed to perform various things define various parts of programming languages viewed to be difficult to formalise including handling binders and freshness they also mention handling of linear typing but renege on actually formulating this as part of their challenge they insist it is a future work here is the future
%% Metatheory library

%% correctness and something what else could we say i think it would appropriate
%% to mention that the session types studied so far include both pi and lambda
%% calculi and it may be beneficil if the reader was informed also the pi
%% calculus paradigms do not fit well into the existing mainstream programming
%% language paradigms this seems like it should be in the statement of the problem section down below also i should read more of jtod's slides because this writing just keep writing malarky might just be what i need to pound out the pages because it eliminates thoughts as they come into the head what else adopt and focus we have in the problem statement but perhaps those paragraphs should be re-jigged for up here multithreaded functional programming with linear typing for session types a number of these systems use different type systems but they are based on all the lambda calculus fundamentally so to have a generic framework to encode these variants would 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statement of Problem}

The aim of this project is to develop a framework for formalising lambda
calculus type systems involving session types using interactive theorem
proving (in particular, the system Coq). The motivation for the framework is
that it will enable a whole class of related languages and type systems to be
formalised with little extra proof effort. Inspired by previous work on a
mechanised framework for pi calculus type systems~\cite{Gay:2001:FFP} we
shift to the lambda calculus to provide a basis on which session types for
mainstream programming languages can be studied whilst taking advantage of
previous proof effort and specialising only for those parts unique to the
particular system. The framework will be heavily based on calculi developed by \citeauthor{Walder:2012}~\cite{Wadler:2012} describing a relationship between classical linear logic (CP) and a functional language with session types (GV). GV is a minimal functional language supporting linearity so I believe such a basis will be general enough to support reasoning about a large class of functional languages with similar base properties.

From this framework, a number of directions can be explored including
session polymorphism, session subtyping, and permitting different forms of
aliasing within the type system. The recent work by \citeauthor{Lindley:2014:SAP} \cite{Lindley:2014:SAP}, who extend GV to HGV supporting session forwarding, replication and polymorphism, would be a interesting place to start when looking to add these extensions.

Additionally, the majority of previous session type systems for mainstream programming languages have focussed exclusively on linear type systems. One disadvantage of a linear type system is the need to re-bind objects after each operation~\cite{Gay:2010:LAST}. We could look to extend the GV type system tho provide the benefits of aliasing with the guarantees of linearity, termed ``adoption and focus'' as introduced by~\citeauthor{Fahndrich:2002} \cite{Fahndrich:2002}. The ``adoption and focus'' type system is non-trivial requiring special language features, e.g. to manage capabilities which can be thought as a form of object liveness mechanism, so the GV typing judgements must be extended such that the capabilities can be included in soundness results. A translation to CP must also be defined for the ``adopt'' and ``focus'' constructs.

These extensions will argue that the framework supports a wide range of languages and type systems, providing researchers the ability to harness the power of formal verification in the design, implementation and documentation of session-based type systems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background Survey}

%% present an overview of relevant previous work including articles, books, and
%% existing software products. Critically evaluate the strengths and weaknesses
%% of the previous work.

The background for this project can be categorised roughly as work on session types (sub-divided into pi and lambda calculi variants, \S \ref{sec:pis} and \S \ref{sec:lam}, respectively) and work on formal verification using proof assistants (particularly focussed on programming language mechanisation). Finally, some recent work has merged these two disciplines by verifying session-based pi calculus systems (\S \ref{sec:asts})

\subsection{Session-based Type Systems and Linear Logic}\label{sec:sts}

\subsubsection{In the \pi Calculus}\label{sec:pis}

So we have work on pi calculus and linear logic by \citeauthor{Caires:2010:STI}~\cite{Caires:2010:STI}.

\subsubsection{In the \lambda Calculus}\label{sec:lam}

Simon Gay inter-process thingL
Previous work by the same authors ... had nonstandard operational semantics due to handling of channels.

The work on a linear functional language with session types by \citeauthor{Gay:2010:LAST}~\cite{Gay:2010:LAST} is the main influence for the current project from the body of work on session-based $\lambda$ calculus type systems. They provide a paper proofs of their systems type (and runtime?) safety. 
Given the systems non-trivial features such as recursive session types (?) and buffered channels it will more difficult to extend these proofs manually. A mechanised version would provide stronger guarantees of correctness and allow others to more easily alter proofs as a result of changes made to the language.

\subsubsection{Fusion}

A number of systems incorporate both a functional language surface syntax with and translation to a more primitive process calculus. \citeauthor{Wadler:2012}'s recent work~\cite{Wadler:2012} fuses together a process calculus, CP, based on earlier work, on a relationship between the $\pi$ calculus and linear logic, by \citeauthor{Caires:2010:STI} with a functional language, GV, based on LAST by \citeauthor{Gay:2010:LAST}. The work describes a continuation-passing style (CPS) translation from GV to CP treating session types as propositions in a classical linear logic.

Other work similar in vain to ... is Lolliproc~\cite{Mazurak:2010:LCC} and classical extension to second-order logic by \citeauthor{Mazurak:2013:LPP}'s PhD thesis~\cite{Mazurak:2013:LPP}.

\subsection{Mechanising Programming Language Metatheory}

\subsubsection{Applications to Session-based Type Systems}\label{sec:asts}

session polymorphism formalised in Coq

\subsection{Formal Tidbits}

Simon's pi calculus framework may be worth mentioning here
System F-pop~\cite{Mazurak:2010:LLT}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}\label{sec:approach}

state how you propose to solve the software development problem. Show that
your proposed approach is feasible, but identify any risks.

First order approach taken - represent bound variables as de Bruijn indices
In contrast to a higher-order approach
though the first-order encoding has its disadvantages namely one has to reason about variable substitution since without a higher-order approach this is not handled automatically by the meta-language
the locally nameless representation is chosen with a few simplifying assumptions regarding variable substitution and closed terms

One may need to avoid certain tricky formulations. For instance, instead of providing n-ary branch and choice in GV, we provide only binary versions of these operators to simplify the development. This change is not restrictive however, since CP itself provides only binary versions of $\par$ and $&$. Likewise, on a more technical note, we almagmate all types into one inductive definition and provide a predicate for restricting propositions to consider only valid session types. \citeauthor{Wadler:2012} defines the GV grammar as a mutually recursive; session types are types which may contain types as subcomponents (arguments to send, for example). Unfortunately, handling mutually inductive definitions in Coq can be quite involved; requiring one to rely on the Coq system being able to provide a stronger mutual induction principle or defining one manual. Such a definition is possible, but it complicates elimination via the induction principle.
( since the standard induction tactic will not work?)

Engineering Formal Metatheory
Abstract:

Formalising programming languages within a proof assistant is becoming a
more widely adopted convention within the research community in lieu of hand
written proofs.

Review:

Discussing issues in engineering metatheory for programming languages.
Focus was on the locally nameless representation for binders with names
for free variables and de Brujin indices for bound variables. There was
also novel use of cofinite quantification to rules with bindings to increase
the strength of the induction principles and reduce the amount of renaming
of bound variables (due to freshness issues) significantly. The theory was
tested with formalisations of the simply-typed lambda calculus,
System $F_{<:}$,
the calculus of constructions. The formalisations followed the POPLMARK
challenge (type soundness, preservation, progress).


The intrinsic encoding as described by~\citeauthor{Benton:2012:STT}~\cite{Benton:2012:STT} is one approach for encoding programming languages based on the lambda calculus. The key idea here is that terms are indexed by their type so as to prevent ill-formed terms from being constructed. However, in the encoding for GV there are issues with using this encoding: $(1)$ it is not immediately clear how to handle linear contexts using the de Bruijn variable encoding, since in the instrinic setting the environment supports weakening; $(2)$ an instrinic encoding of terms would be complicated by the need to enforce session types occur in certain instances (by use of a predicate); and $(3)$ well-typed terms require extra assumptions about binder freshness which cannot reasonably be expressed as a function type. For these reasons, an instrinic approach does not offer much benefit since a well-typed term relation would still need to be defined. I chose the ..... encoding


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

show how you plan to organize your work, identifying intermediate deliverables
and dates.

I aim to have completed the GV and CP definitions complete with reduction and commuting conversion rules for CP by the end of December. This will require definition of infrastructure for handling binders for both GV, CP channels and CP propositional variables; I hope to be able to generalise as much as possible with the help of the UPenn Metatheory library.

It remains to define the translation between GV and CP which I envisage will be the bulk of the work, requiring several rules on typing derivations; I envisage being able to define these as inductive datatype constructors.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printbibliography

\end{document}
