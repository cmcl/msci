<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>MetatheoryAlt</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library MetatheoryAlt</h1>

<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Arith.Arith.html#"><span class="id" type="library">Coq.Arith.Arith</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.FSets.FSets.html#"><span class="id" type="library">Coq.FSets.FSets</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Lists.List.html#"><span class="id" type="library">Coq.Lists.List</span></a>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="CoqEqDec.html#"><span class="id" type="library">CoqEqDec</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="CoqListFacts.html#"><span class="id" type="library">CoqListFacts</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="LibTactics.html#"><span class="id" type="library">LibTactics</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="MetatheoryAtom.html#"><span class="id" type="library">MetatheoryAtom</span></a>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="AssumeList.html#"><span class="id" type="library">AssumeList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab239"></a><h1 class="section">Decidable equality</h1>

<div class="paragraph"> </div>

 We prefer that "==" refer to decidable equality at <span class="inlinecode"><span class="id" type="var">eq</span></span>, as
    defined by the <span class="inlinecode"><span class="id" type="var">EqDec_eq</span></span> class from the CoqEqDec library. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name=":coqeqdec_scope:x_'=='_x"><span class="id" type="notation">"</span></a> x  == y " := (<a class="idref" href="CoqEqDec.html#eq_dec"><span class="id" type="definition">eq_dec</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70) : <span class="id" type="var">coqeqdec_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">coqeqdec_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab240"></a><h1 class="section">Notations for finite sets of atoms</h1>

<div class="paragraph"> </div>

 Common set operations and constants may be written using more
    convenient notations. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_scope:x_'[=]'_x"><span class="id" type="notation">"</span></a>E [=] F" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.Equal"><span class="id" type="definition">AtomSetImpl.Equal</span></a> <span class="id" type="var">E</span> <span class="id" type="var">F</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="keyword">no</span> <span class="id" type="keyword">associativity</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_scope:x_'[<=]'_x"><span class="id" type="notation">"</span></a>E [&lt;=] F" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.Subset"><span class="id" type="definition">AtomSetImpl.Subset</span></a> <span class="id" type="var">E</span> <span class="id" type="var">F</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="keyword">no</span> <span class="id" type="keyword">associativity</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_scope:'{}'"><span class="id" type="notation">"</span></a>{}" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.empty"><span class="id" type="axiom">AtomSetImpl.empty</span></a>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_scope:'{{'_x_'}}'"><span class="id" type="notation">"</span></a>{{  x  }}" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.singleton"><span class="id" type="axiom">AtomSetImpl.singleton</span></a> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_hs_scope:x_'`in`'_x"><span class="id" type="notation">"</span></a>x `in` E" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.In"><span class="id" type="axiom">AtomSetImpl.In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">E</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_hs_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">"</span></a>x `notin` E" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.In"><span class="id" type="axiom">AtomSetImpl.In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">E</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_hs_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_hs_scope:x_'`union`'_x"><span class="id" type="notation">"</span></a>E `union` F" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.union"><span class="id" type="axiom">AtomSetImpl.union</span></a> <span class="id" type="var">E</span> <span class="id" type="var">F</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 65, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>, <span class="id" type="var">format</span> "E  `union`  '/' F")<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_hs_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We define some abbreviations for the empty set, singleton
    sets, and the union of two sets. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name="add"><span class="id" type="abbreviation">add</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.add"><span class="id" type="axiom">AtomSetImpl.add</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="empty"><span class="id" type="abbreviation">empty</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.empty"><span class="id" type="axiom">AtomSetImpl.empty</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="remove"><span class="id" type="abbreviation">remove</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.remove"><span class="id" type="axiom">AtomSetImpl.remove</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="singleton"><span class="id" type="abbreviation">singleton</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.singleton"><span class="id" type="axiom">AtomSetImpl.singleton</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="union"><span class="id" type="abbreviation">union</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.union"><span class="id" type="axiom">AtomSetImpl.union</span></a>.<br/>

<br/>
</div>

<div class="doc">
Open the notation scopes declared above. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">set_scope</span>.<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">set_hs_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab241"></a><h1 class="section">Environments</h1>

<div class="paragraph"> </div>

 As an alternative to the <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" type="var">a</span></span> notation, we also provide more
    list-like notation for writing association lists consisting of a
    single binding.

<div class="paragraph"> </div>

    Implementation note: The following notation overlaps with the
    standard recursive notation for lists, e.g., the one found in the
    Program library of Coq's standard library. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab242"></a><h1 class="section">Cofinite quantification</h1>

<div class="paragraph"> </div>

 Consider a rule <span class="inlinecode"><span class="id" type="var">H</span></span> (equivalently, constructor, lemma, etc.) whose
    type begins with <span class="inlinecode"><span class="id" type="keyword">forall</span></span> <span class="inlinecode"><span class="id" type="var">L</span>,</span> <span class="inlinecode">...</span> and contains hypotheses of the
    form <span class="inlinecode">(<span class="id" type="keyword">forall</span></span> <span class="inlinecode"><span class="id" type="var">y</span>,</span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">`<span class="id" type="var">notin</span>`</span> <span class="inlinecode"><span class="id" type="var">L</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...)</span>.

<div class="paragraph"> </div>

    The tactic <span class="inlinecode">(<span class="id" type="var">pick</span></span> <span class="inlinecode"><span class="id" type="tactic">fresh</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">excluding</span></span> <span class="inlinecode"><span class="id" type="var">F</span></span> <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span>)</span> applies <span class="inlinecode"><span class="id" type="var">H</span></span> to
    the current goal, instantiating <span class="inlinecode"><span class="id" type="var">H</span></span>'s first argument (<span class="inlinecode"><span class="id" type="var">L</span></span>) with
    the finite set of atoms <span class="inlinecode"><span class="id" type="var">F</span></span>.  In each new subgoal of the form
    <span class="inlinecode">(<span class="id" type="keyword">forall</span></span> <span class="inlinecode"><span class="id" type="var">y</span>,</span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">`<span class="id" type="var">notin</span>`</span> <span class="inlinecode"><span class="id" type="var">F</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...)</span>, the atom <span class="inlinecode"><span class="id" type="var">y</span></span> is introduced as
    <span class="inlinecode"><span class="id" type="var">x</span></span>, and <span class="inlinecode">(<span class="id" type="var">y</span></span> <span class="inlinecode">`<span class="id" type="var">notin</span>`</span> <span class="inlinecode"><span class="id" type="var">F</span>)</span> is introduced using a generated name.

<div class="paragraph"> </div>

    If we view <span class="inlinecode"><span class="id" type="var">H</span></span> as a rule that uses cofinite quantification, the
    tactic can be read as picking a sufficiently fresh atom to open a
    term with. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;"pick" "fresh" <span class="id" type="var">ident</span>(<span class="id" type="var">atom_name</span>)<br/>
&nbsp;&nbsp;"excluding" <span class="id" type="keyword">constr</span>(<span class="id" type="var">L</span>)<br/>
&nbsp;&nbsp;"and" "apply" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>)<br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">first</span> [<span class="id" type="tactic">apply</span> (@<span class="id" type="var">H</span> <span class="id" type="var">L</span>) | <span class="id" type="tactic">eapply</span> (@<span class="id" type="var">H</span> <span class="id" type="var">L</span>)];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="keyword">forall</span> <span class="id" type="var">_</span>, <span class="id" type="var">_</span> <a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">notin</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a> <span class="id" type="var">_</span> -&gt; <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Fr</span> := <span class="id" type="tactic">fresh</span> "Fr" <span class="id" type="keyword">in</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">atom_name</span> <span class="id" type="var">Fr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="keyword">forall</span> <span class="id" type="var">_</span>, <span class="id" type="var">_</span> <a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">notin</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a> <span class="id" type="var">_</span> -&gt; <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">fail</span> 1 "because" <span class="id" type="var">atom_name</span> "is already defined"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The following variant of the tactic excludes the set of atoms
    returned by the <span class="inlinecode"><span class="id" type="var">gather_atoms</span></span> tactic.  Redefine <span class="inlinecode"><span class="id" type="var">gather_atoms</span></span> if
    you wish to modify the behavior of this tactic. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;"pick" "fresh" <span class="id" type="var">ident</span>(<span class="id" type="var">atom_name</span>)<br/>
&nbsp;&nbsp;"and" "apply" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>)<br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">L</span> := <span class="id" type="var">gather_atoms</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">L</span> := <span class="id" type="var">beautify_fset</span> <span class="id" type="var">L</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pick</span> <span class="id" type="tactic">fresh</span> <span class="id" type="var">atom_name</span> <span class="id" type="var">excluding</span> <span class="id" type="var">L</span> <span class="id" type="var">and</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab243"></a><h1 class="section">Lemma aliases</h1>

<div class="paragraph"> </div>

 A number of useful lemmas are given standardized, if somewhat
    unintuitive, names.  Here, we define some intuitive aliases for
    them. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name="uniq_one"><span class="id" type="abbreviation">uniq_one</span></a> := <a class="idref" href="AssumeList.html#uniq_one_1"><span class="id" type="lemma">uniq_one_1</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="uniq_cons"><span class="id" type="abbreviation">uniq_cons</span></a> := <a class="idref" href="AssumeList.html#uniq_cons_3"><span class="id" type="lemma">uniq_cons_3</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="uniq_app"><span class="id" type="abbreviation">uniq_app</span></a> := <a class="idref" href="AssumeList.html#uniq_app_4"><span class="id" type="lemma">uniq_app_4</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="uniq_map"><span class="id" type="abbreviation">uniq_map</span></a> := <a class="idref" href="AssumeList.html#uniq_map_2"><span class="id" type="lemma">uniq_map_2</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="binds_one"><span class="id" type="abbreviation">binds_one</span></a> := <a class="idref" href="AssumeList.html#binds_one_3"><span class="id" type="lemma">binds_one_3</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="binds_cons"><span class="id" type="abbreviation">binds_cons</span></a> := <a class="idref" href="AssumeList.html#binds_cons_3"><span class="id" type="lemma">binds_cons_3</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="binds_app_l"><span class="id" type="abbreviation">binds_app_l</span></a> := <a class="idref" href="AssumeList.html#binds_app_2"><span class="id" type="lemma">binds_app_2</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="binds_app_r"><span class="id" type="abbreviation">binds_app_r</span></a> := <a class="idref" href="AssumeList.html#binds_app_3"><span class="id" type="lemma">binds_app_3</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="binds_map"><span class="id" type="abbreviation">binds_map</span></a> := <a class="idref" href="AssumeList.html#binds_map_2"><span class="id" type="lemma">binds_map_2</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="notin_empty"><span class="id" type="abbreviation">notin_empty</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_empty_1"><span class="id" type="lemma">notin_empty_1</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="notin_add"><span class="id" type="abbreviation">notin_add</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_add_3"><span class="id" type="lemma">notin_add_3</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="notin_singleton"><span class="id" type="abbreviation">notin_singleton</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_singleton_2"><span class="id" type="lemma">notin_singleton_2</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="notin_union"><span class="id" type="abbreviation">notin_union</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_union_3"><span class="id" type="lemma">notin_union_3</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab244"></a><h1 class="section">Hints</h1>

<div class="paragraph"> </div>

 The next block of hints is to help <span class="inlinecode"><span class="id" type="tactic">auto</span></span> discharge many of the
    inequality and freshness goals that arise in programming language
    metatheory proofs. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">hint_extern_solve_notin</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">rewr_dom</span> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="var">destruct_notin</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">first</span> [ <span class="id" type="tactic">apply</span> <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_union_3"><span class="id" type="lemma">notin_union_3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">apply</span> <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_add_3"><span class="id" type="lemma">notin_add_3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">apply</span> <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_singleton_2"><span class="id" type="lemma">notin_singleton_2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">apply</span> <a class="idref" href="MetatheoryAtom.html#AtomSetNotin.notin_empty_1"><span class="id" type="lemma">notin_empty_1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;];<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">tauto</span>.<br/>

<br/>
<span class="id" type="keyword">Hint Extern</span> 1 (<span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x_':>'_x"><span class="id" type="notation">&lt;&gt;</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x_':>'_x"><span class="id" type="notation">:&gt;</span></a> <span class="id" type="var">_</span>) =&gt; <span class="id" type="var">hint_extern_solve_notin</span>.<br/>

<br/>
<span class="id" type="keyword">Hint Extern</span> 1 (<span class="id" type="var">_</span> <a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">notin</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a> <span class="id" type="var">_</span>) =&gt; <span class="id" type="var">hint_extern_solve_notin</span>.<br/>

<br/>
</div>

<div class="doc">
The next block of hints are occasionally useful when reasoning
    about finite sets.  In some instances, they obviate the need to
    use <span class="inlinecode"><span class="id" type="tactic">auto</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="tactic">set</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Hint Resolve</span><br/>
&nbsp;&nbsp;<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.add_1"><span class="id" type="axiom">AtomSetImpl.add_1</span></a> <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.add_2"><span class="id" type="axiom">AtomSetImpl.add_2</span></a> <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.remove_1"><span class="id" type="axiom">AtomSetImpl.remove_1</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.remove_2"><span class="id" type="axiom">AtomSetImpl.remove_2</span></a> <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.singleton_2"><span class="id" type="axiom">AtomSetImpl.singleton_2</span></a> <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.union_2"><span class="id" type="axiom">AtomSetImpl.union_2</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="MetatheoryAtom.html#AtomSetImpl.union_3"><span class="id" type="axiom">AtomSetImpl.union_3</span></a> <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.inter_3"><span class="id" type="axiom">AtomSetImpl.inter_3</span></a> <a class="idref" href="MetatheoryAtom.html#AtomSetImpl.diff_3"><span class="id" type="axiom">AtomSetImpl.diff_3</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab245"></a><h1 class="section">Ott compatibility</h1>

<div class="paragraph"> </div>

 Implementation note (BEA): The following definitions make this
    library usable with the output of Ott's locally nameless backend.
    They may disappear or change as Ott changes. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name="var"><span class="id" type="abbreviation">var</span></a> := <a class="idref" href="MetatheoryAtom.html#AtomImpl.atom"><span class="id" type="axiom">atom</span></a> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>).<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="vars"><span class="id" type="abbreviation">vars</span></a> := <a class="idref" href="MetatheoryAtom.html#atoms"><span class="id" type="abbreviation">atoms</span></a> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>).<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="eq_var"><span class="id" type="abbreviation">eq_var</span></a> := <a class="idref" href="CoqEqDec.html#eq_dec"><span class="id" type="definition">eq_dec</span></a> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>).<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":coqeqdec_scope:x_'==='_x"><span class="id" type="notation">"</span></a>x  ===  y" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">x</span> <a class="idref" href="MetatheoryAlt.html#:coqeqdec_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="var">only</span> <span class="id" type="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">coqeqdec_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_sl_scope:x_'\in'_x"><span class="id" type="notation">"</span></a>x \in s" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">x</span> <a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`in`'_x"><span class="id" type="notation">`</span></a><span class="id" type="keyword">in</span><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`in`'_x"><span class="id" type="notation">`</span></a> <span class="id" type="var">s</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="var">only</span> <span class="id" type="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_sl_scope:x_'\notin'_x"><span class="id" type="notation">"</span></a>x \notin s" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">x</span> <a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">notin</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`notin`'_x"><span class="id" type="notation">`</span></a> <span class="id" type="var">s</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="var">only</span> <span class="id" type="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":set_sl_scope:x_'\u'_x"><span class="id" type="notation">"</span></a>s \u t" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">s</span> <a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`union`'_x"><span class="id" type="notation">`</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`union`'_x"><span class="id" type="notation">union</span></a><a class="idref" href="MetatheoryAlt.html#:set_hs_scope:x_'`union`'_x"><span class="id" type="notation">`</span></a> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 65, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>, <span class="id" type="var">only</span> <span class="id" type="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">gather_vars_with</span> <span class="id" type="var">F</span> := <span class="id" type="var">gather_atoms_with</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">pick_fresh_gen</span> <span class="id" type="var">L</span> <span class="id" type="var">Y</span> := <span class="id" type="var">pick</span> <span class="id" type="tactic">fresh</span> <span class="id" type="var">Y</span> <span class="id" type="keyword">for</span> <span class="id" type="var">L</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "auto" "*" := <span class="id" type="tactic">auto</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">apply_fresh_base</span> <span class="id" type="var">H</span> <span class="id" type="var">gather_vars</span> <span class="id" type="var">atom_name</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">L</span> := <span class="id" type="var">gather_vars</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">L</span> := <span class="id" type="var">beautify_fset</span> <span class="id" type="var">L</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="var">pick</span> <span class="id" type="tactic">fresh</span> <span class="id" type="var">x</span> <span class="id" type="var">excluding</span> <span class="id" type="var">L</span> <span class="id" type="var">and</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="env"><span class="id" type="definition">env</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) := <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> (<a class="idref" href="MetatheoryAtom.html#AtomImpl.atom"><span class="id" type="axiom">atom</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <a class="idref" href="MetatheoryAlt.html#A"><span class="id" type="variable">A</span></a>).<br/>

<br/>
</div>

<div class="doc">
We provide alternative names for tactics on association lists. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_env</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">simpl_asnlist</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "simpl_env" "in" <span class="id" type="var">hyp</span>(<span class="id" type="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">simpl_asnlist</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "simpl_env" "in" "*" :=<br/>
&nbsp;&nbsp;<span class="id" type="var">simpl_asnlist</span> <span class="id" type="keyword">in</span> *.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "rewrite_env" <span class="id" type="keyword">constr</span>(<span class="id" type="var">E</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">rewrite_asnlist</span> <span class="id" type="var">E</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "rewrite_env" <span class="id" type="keyword">constr</span>(<span class="id" type="var">E</span>) "in" <span class="id" type="var">hyp</span>(<span class="id" type="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">rewrite_asnlist</span> <span class="id" type="var">E</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>